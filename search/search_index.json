{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<ul> <li>tilnoene / Tilnoene</li> </ul>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li>Tiagodfs's Library</li> <li>quirino.net</li> <li>WeakestTopology's Library</li> <li>KACTL</li> <li>CP-Algorithms</li> <li>AtCoder Problems</li> <li>Dynamic A2OJ</li> <li>Algorithms Live!</li> </ul>"},{"location":"all_topics/","title":"All topics","text":"<p>All topics I want to learn</p> <p>TODO: Put USACO links and contents</p> <ul> <li>Trees<ul> <li>Small to Large</li> <li>HLD</li> <li>DFS Tree</li> </ul> </li> <li>Math<ul> <li>Expected Value</li> <li>Number Theory</li> <li>Divisibility</li> <li>Probability</li> <li>Combinatorics</li> <li>Game Theory</li> </ul> </li> <li>Geometry<ul> <li>Dot and Cross product</li> <li>Convex Hull</li> </ul> </li> <li>String<ul> <li>Hash</li> <li>Suffix Array</li> <li>Z-algo</li> <li>KMP</li> </ul> </li> <li>Dynamic Programming<ul> <li>Profile DP</li> <li>Digit DP</li> <li>DP on Tree</li> </ul> </li> <li>Graph<ul> <li>Review Dijkstra, Floyd Warhsall, Bellman Ford</li> </ul> </li> <li>DSA<ul> <li>DSU</li> <li>Segtree</li> <li>LCA</li> <li>Binary Search</li> <li>Ternary Search</li> <li>Prefix Sum</li> <li>Two Pointers</li> <li>Sliding Window</li> </ul> </li> <li>Other<ul> <li>Simulation</li> <li>Constructive</li> <li>SQRT Decomposition + MO</li> <li>Centroid</li> <li></li> </ul> </li> </ul>"},{"location":"recommended_problems/","title":"Recommended problems","text":"<p>Problems I recommend you solve.</p> <ul> <li>abc325_e</li> <li>HackerCup Round 2 B</li> <li>2023 Mexico 2da Fecha E</li> <li>2023 Mexico 2da Fecha B</li> <li>2023 Mexico 2da Fecha A</li> <li>2023 Mexico 2da Fecha D</li> <li>2023 Mexico 2da Fecha L</li> <li>abc325_d</li> </ul>"},{"location":"upsolving/","title":"Upsolving","text":"<p>Minha lista de upsolving</p> <ul> <li>Hackercup Round 2 C: Wiki Race</li> <li>Hackercup Round 2 A2</li> <li></li> </ul>"},{"location":"intensivao/Day%201%20-%20Complete%20Search/","title":"Day 1   Complete Search","text":"<p>imposs\u00edvel n\u00e3o achar se olharmos em todos os locais</p> <p>A busca completa consiste em iterar por todo o espa\u00e7o de solu\u00e7\u00e3o. Note que isso n\u00e3o significa que voc\u00ea tem que iterar por todo o espa\u00e7o de busca, pois muitas vezes voc\u00ea ter\u00e1 um conjunto de elementos que d\u00e3o a mesma resposta n\u00e3o por acaso, e sim por todos manterem alguma propriedade no qual podemos considerar todos eles como um s\u00f3.</p> <p>Por\u00e9m, em diversos problemas mais simples voc\u00ea pode (e deve) iterar por todo o espa\u00e7o de busca, poupando tempo e racioc\u00ednio, al\u00e9m de evitar poss\u00edveis casos de borda.</p>"},{"location":"intensivao/Day%201%20-%20Complete%20Search/#materiais","title":"Materiais","text":""},{"location":"intensivao/Day%201%20-%20Complete%20Search/#problemas","title":"Problemas","text":"<ul> <li>Milk Pails</li> <li>Cow Gymnastics</li> <li>Load Balancing</li> </ul>"},{"location":"training/Brasil/UNICAMP_Selection_Contest_2023/","title":"UNICAMP Selection Contest 2023","text":"<p>Feito em 25/08/2023</p>"},{"location":"training/Nacionais/2017/","title":"2017-2018 ACM-ICPC Latin American Regional Programming Contest","text":"<p>Feito em 13/10/2023</p> C. Complete Naebbirac's sequence <p>     S\u00f3 fazer.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n\nusing namespace std;\nusing vi = vector&lt;int&gt;;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing ld = long double;\n\nvoid solve() {\n    int n, k; cin &gt;&gt; k &gt;&gt; n;\n    vector&lt;int&gt; arr(n);\n\n    map&lt;int, int&gt; cnt;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; arr[i];\n        cnt[arr[i]]++;\n    }\n\n    for(int i = 1; i &lt;= k; i++) {\n        cnt[i] += 1;\n\n        set&lt;int&gt; s;\n\n        for(auto &amp;[ff, ss] : cnt) {\n            s.insert(ss);\n        }\n\n        if((int)s.size() == 1) {\n            cout &lt;&lt; \"+\" &lt;&lt; i &lt;&lt; \"\\n\";\n            return;\n        }\n\n        cnt[i]--;\n    }\n\n    for(int i = 1; i &lt;= k; i++) {\n        cnt[i] -= 1;\n\n        set&lt;int&gt; s;\n\n        for(auto &amp;[ff, ss] : cnt) {\n            s.insert(ss);\n        }\n\n        if((int)s.size() == 1) {\n            cout &lt;&lt; \"-\" &lt;&lt; i &lt;&lt; \"\\n\";\n            return;\n        }\n\n        cnt[i]++;\n    }\n\n    // caso 3 -&gt; n - 2 caras aparecem uma quantidade igual de vezes\n    // apenas 2 errados\n\n    map&lt;int, int&gt; mp;\n\n    for(auto &amp;[ff, ss] : cnt) {\n        mp[ss] += 1;\n    }\n\n    if((int)mp.size() != 3) {\n        cout &lt;&lt; \"*\\n\";\n        return;\n    } else {\n\n        auto x = mp.begin()-&gt;ff;\n        auto y = prev(mp.end())-&gt;ff;\n        auto need = next(mp.begin())-&gt;ff;\n\n        if( x + 1 != need || y - 1 != need) {\n            cout &lt;&lt; \"*\\n\";\n            return; \n        }\n\n        // agora basta printar um valor que aparece x vezes e um que aparece y\n\n        int ans_x = -1, ans_y = -1;\n\n        for(auto &amp;[ff, ss] : cnt) {\n            if(ss == x) ans_x = ff;\n            if(ss == y) ans_y = ff;\n        }\n\n        cout &lt;&lt; \"-\" &lt;&lt; ans_y &lt;&lt; \" +\" &lt;&lt; ans_x &lt;&lt; \"\\n\";\n        return;\n\n    }\n\n    cout &lt;&lt; \"*\\n\";\n\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    solve();\n\n    return 0;\n}\n</code></pre> E. Enigma <p>     DP de d\u00edgito cl\u00e1ssica, dp[posicao][resto] = \u00e9 possivel construir o n\u00famero? A transi\u00e7\u00e3o \u00e9 tentar colocar os d\u00edgitos de 0 at\u00e9 10, tratando os detalhes como: como o resto muda? o primeiro d\u00edgito n\u00e3o pode ser 0 e o caractere j\u00e1 existir na string. Ap\u00f3s isso, um guloso para recuperar a resposta lexicograficamente da DP (se existir).   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n#define int long long\n\nusing namespace std;\nusing vi = vector&lt;int&gt;;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing ld = long double;\n\nconst int MAX = 1e3+10;\n\nint dp[MAX][MAX];\nstring s; int num;\nint n;\n\nint solve(int pos, int rem) {\n  if (pos &gt;= n) return dp[pos][rem] = (rem == 0);\n  int&amp; memo = dp[pos][rem];\n\n  if (memo != -1) return memo;\n  memo = 0;\n\n  if (s[pos] != '?') {\n    int new_rem = rem * 10 + (s[pos] - '0');\n    new_rem %= num;\n    return memo |= solve(pos + 1, new_rem);\n  }\n\n  for (int d = 0; d &lt;= 9; d++) {\n    if (pos == 0 &amp;&amp; d == 0) continue;\n    int new_rem = rem * 10 + d;\n    new_rem %= num;\n    memo |= solve(pos + 1, new_rem);\n  }\n\n  return memo;\n}\n\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  cin &gt;&gt; s;\n  cin &gt;&gt; num;\n  n = s.size();\n\n  memset(dp, -1, sizeof(dp));\n\n  if (solve(0, 0) == 0) {\n    cout &lt;&lt; \"*\\n\";\n    return 0;\n  }\n\n  string ans = \"\";\n  int rem = 0;\n  for (int i = 0; i &lt; n; i++) {\n    if (s[i] != '?') {\n      ans += s[i];\n      int new_rem = rem * 10 + (s[i] - '0');\n      new_rem %= num;\n      rem = new_rem;\n      continue;\n    }\n    for (int d = 0; d &lt;= 9; d++) {\n      if (i == 0 &amp;&amp; d == 0) continue;\n      int new_rem = rem * 10 + d;\n      new_rem %= num;\n      if (dp[i + 1][new_rem] == 1) {\n        ans += char(d + '0');\n        rem = new_rem;\n        break;\n      }\n    }\n  }\n\n  cout &lt;&lt; ans &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre> F. Fundraising <p>     Problema muito interessante, n\u00e3o d\u00e1 pra fazer com seg 2D (tomamos TLE). A ideia \u00e9 parecida com a LIS. Separa os pontos pelos que tem mesmo x, e ent\u00e3o processa todos de uma vez, ordenados. A resposta do ponto (x, y) vai ser a melhor resposta do ret\u00e2ngulo [0, 0] [x - 1, y - 1] + a doa\u00e7\u00e3o dele. No fim, a resposta \u00e9 o maior valor da DP. \u00c9 poss\u00edvel fazer a query de uma forma mais eficiente, somente com seg 1D. Explica\u00e7\u00e3o com pressa, veja o c\u00f3digo para mais detalhes.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n#define int long long\n\nusing namespace std;\nusing vi = vector&lt;int&gt;;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing ld = long double;\nusing ll = long long;\n\nconst int MAX = (int)4e5 + 17;\n\nstruct Segtree {\n\n    int n;\n    vector&lt;ll&gt; seg;\n\n    Segtree(int n_) {\n        n = n_;\n        seg.resize(4 * n, 0);\n    }\n\n    ll merge(ll a, ll b) {\n        return max(a, b);\n    }\n\n    ll q(int x, int l, int r, int i, int j) {\n        if(r &lt; i || l &gt; j) return 0;\n        if(l &gt;= i &amp;&amp; r &lt;= j) return seg[x];\n        int mid = l + (r - l) / 2;\n        return merge(q(x + x, l, mid, i, j), q(x + x + 1, mid + 1, r, i, j));\n    }\n\n    void att(int x, int l, int r, int posi, ll val) {\n        if(l == r) {\n            seg[x] = val;\n        } else {\n            int mid = l + (r - l) / 2;\n            if(posi &lt;= mid) att(x + x, l, mid, posi, val);\n            else att(x + x + 1, mid + 1, r, posi, val);\n            seg[x] = merge(seg[x + x], seg[x + x + 1]);\n        }\n    }\n\n    ll query(int l, int r) {\n        return q(1, 0, n - 1, l, r);\n    }\n\n    void update(int posi, ll val) {\n        att(1, 0, n - 1, posi, val);\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int k; cin &gt;&gt; k;\n    vector&lt;array&lt;int, 3&gt;&gt; arr;\n\n    map&lt;pair&lt;int, int&gt;, int&gt; cnt;\n\n    set&lt;int&gt; aux;\n\n    for (int i = 0; i &lt; k; i++) {\n        int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n        cnt[{a, b}] += c;\n\n        aux.insert(a);\n        aux.insert(b);\n    }\n\n    map&lt;int, int&gt; idx;\n\n    int it = 2;\n    for (auto e : aux) {\n        idx[e] = it++;\n    }\n\n    for (auto [ff, ss] : cnt) {\n        arr.push_back({ idx[ff.ff], idx[ff.ss], ss });\n    }\n\n    sort(arr.begin(), arr.end());\n\n    Segtree seg(MAX);\n\n    map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; blocks;\n\n    for (auto [x, y, d] : arr) {\n        blocks[x].push_back({ y, d });\n    }\n\n    for (auto [key, val] : blocks) {\n        map&lt;int, int&gt; ans;\n\n        for (auto [y, d] : val) {\n            ans[y] = seg.query(0, y - 1) + d;\n        }\n\n        for (auto [y, d] : val) {\n            seg.update(y, max(seg.query(y, y), ans[y]));\n        }\n    }\n\n    cout &lt;&lt; seg.query(0, MAX - 1) &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> H. Hard choice <p>     S\u00f3 fazer.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n\nusing namespace std;\nusing vi = vector&lt;int&gt;;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing ld = long double;\n\nvoid solve() {\n    int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    int d, e, f; cin &gt;&gt; d &gt;&gt; e &gt;&gt; f;\n\n    cout &lt;&lt; max(d - a, 0) + max(e - b, 0) + max(f - c, 0) &lt;&lt; '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    solve();\n\n    return 0;\n}\n</code></pre> I. Imperial roads <p>     A resposta antes das queries \u00e9 a MST do grafo. Ap\u00f3s isso, para cada query de u at\u00e9 v, a resposta \u00e9 o peso da MST - o peso da menor aresta entre u e v + o peso da aresta de u at\u00e9 v. \u00c9 poss\u00edvel responder a query com sparse table ou HLD.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n\nusing namespace std;\nusing vi = vector&lt;int&gt;;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing ld = long double;\n\nstruct QueryTree {\n    int n, t = 0, l = 3, build = 0, euler = 0;\n    vector&lt;ll&gt; dist;\n    vector&lt;int&gt; in, out, d;\n    vector&lt;vi&gt; sobe;\n    vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; arr;\n    vector&lt;vector&lt;ll&gt;&gt; table_max;\n\n    QueryTree(int nn) {\n        n = nn + 5;\n        arr.resize(n);\n        in.resize(n);\n        out.resize(n);\n        d.resize(n);\n        dist.resize(n);\n        while( (1 &lt;&lt; l) &lt; n ) l++;\n        sobe.assign(n + 5, vector&lt;int&gt;(++l));\n        table_max.assign(n + 5, vector&lt;ll&gt;(l));\n    }\n\n    void add_edge(int u, int v, ll w) {\n        arr[u].push_back({v, w});\n        arr[v].push_back({u, w});\n    }\n\n    void Euler_Tour(int u, int last = 0, ll we = 0,  int depth = 0, ll sum = 0) {\n        euler = 1;\n        in[u] = t++;\n        d[u] = depth;\n        dist[u] = sum;\n        sobe[u][0] = last;\n        table_max[u][0] = we;\n        for(auto &amp;v : arr[u]) {\n            if(v.ff != last) {\n                Euler_Tour(v.ff, u, v.ss, depth + 1, sum + v.ss);\n            }\n        }\n        out[u] = t++;\n    }\n\n    void build_table() {\n        assert(euler);\n        build = 1;\n        for(int k = 1; k &lt; l; k++) {\n            for(int i = 1; i &lt;= n; i++) {\n                sobe[i][k] = sobe[sobe[i][k - 1]][k - 1];\n                table_max[i][k] = max(table_max[i][k - 1], table_max[sobe[i][k - 1]][k - 1]);\n            }\n        }\n    }\n\n    int is_ancestor(int u, int v) {\n        assert(euler);\n        return in[u] &lt;= in[v] &amp;&amp; out[u] &gt;= out[v];\n    }\n\n    int lca(int u, int v) {\n        assert(build &amp;&amp; euler);\n        if(is_ancestor(u, v)) return u;\n        if(is_ancestor(v, u)) return v;\n\n        int lca = u;\n\n        for(int k = l - 1; k &gt;= 0; k--) {\n            int tmp = sobe[lca][k];\n            if(!is_ancestor(tmp, v)) {\n                lca = tmp;\n            }\n        }\n\n        return sobe[lca][0];\n\n    }\n\n    ll goUpMax(int u, int to) {\n        assert(build);\n        if(u == to) return 0;\n        ll mx = table_max[u][0];\n        for(int k = l - 1; k &gt;= 0; k--) {\n            int tmp = sobe[u][k];\n            if(!is_ancestor(tmp, to)) {\n                mx = max(mx, table_max[u][k]);\n                u = tmp;\n            }\n        }\n        return max(mx, table_max[u][0]);\n    }\n\n    ll max_edge(int u, int v) {\n        assert(build);\n        if(u == v) return -1;\n        int ancestor = lca(u, v);\n        ll a = goUpMax(u, ancestor), b = goUpMax(v, ancestor);\n        if(ancestor == u) return b;\n        else if(ancestor == v) return a;\n        return max(a, b);\n    }\n\n};\n\nstruct DSU {\n    int n = 0;\n    vector&lt;int&gt; parent;\n    vector&lt;int&gt; sz;\n\n    DSU(int nn) {\n        n = nn;\n        sz.assign(n + 5, 1);\n        parent.assign(n + 5, 0);\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if(x == parent[x]) return x;\n        return parent[x] = find(parent[x]);\n    }\n\n    void join(int a, int b) {\n        a = find(a);\n        b = find(b);\n        if(a == b) return;\n        if(sz[a] &lt; sz[b]) swap(a, b);\n        parent[b] = a;\n        sz[a] += sz[b];\n    }\n\n};\n\nvoid solve() {\n\n    int n, r;\n    cin &gt;&gt; n &gt;&gt; r;\n\n    vector&lt;array&lt;int, 3&gt;&gt; edges_dsu;\n\n    map&lt;int, map&lt;int, int&gt;&gt; edges;\n\n\n    for(int i = 0; i &lt; r; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        a--; b--;\n        edges_dsu.push_back({c, a, b});\n        edges[a][b] = c;\n        edges[b][a] = c;\n    }\n\n    DSU dsu(n);\n\n    sort(edges_dsu.begin(), edges_dsu.end());\n\n    QueryTree qt(n);\n\n    ll mst_cost = 0;\n\n    for(auto &amp;[c, a, b] : edges_dsu) {\n        if(dsu.find(a) != dsu.find(b)) {\n            dsu.join(a, b);\n            qt.add_edge(a, b, c);\n            mst_cost += c;\n        }\n    }\n\n\n    qt.Euler_Tour(0);\n    qt.build_table();\n\n    int q;\n\n    cin &gt;&gt; q;\n\n    while(q--) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        u--; v--;\n\n        ll mx_path = qt.max_edge(u, v);\n\n        cout &lt;&lt; mst_cost - mx_path + edges[u][v] &lt;&lt; \"\\n\";\n\n    }\n\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    solve();\n\n    return 0;\n}\n</code></pre> J. Jumping Frog <p>     ?   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n\nusing namespace std;\nusing vi = vector&lt;int&gt;;\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing ld = long double;\n\nint n;\nstring s;\n\nmap&lt;int, int&gt; mp;\n\nint check(int k) {\n\n    if(mp.find(k) != mp.end()) {\n        return mp[k];\n    }\n\n    int&amp; ans = mp[k];\n\n    vector&lt;int&gt; p(k, 1);\n\n    for(int i = 0; i &lt; n; i++) {\n        if(s[i] == 'P') {\n            p[i % k] = 0;\n        }\n    }\n\n    for(auto &amp;x : p) {\n        ans |= x;\n    }\n\n    return ans;\n\n}\n\nvoid solve() {\n\n    cin &gt;&gt; s;\n\n    n = (int)s.size();\n\n    int ans = 0;\n\n    for(int i = 1; i &lt; n; i++) {\n        if(check(gcd(i, n))) {\n            ans += 1;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    solve();\n\n    return 0;\n}\n</code></pre>"},{"location":"training/Nacionais/2017/#upsolving","title":"Upsolving","text":"<p>B G K</p>"},{"location":"training/Nacionais/2022/","title":"2022-2023 ACM-ICPC Latin American Regional Programming Contest","text":"<p>Feito em 16/09/2023</p> A. Asking for Money <p>     Pra cada i, procura quem seria o n\u00f3 que ser\u00e1 \"pedido\" por algu\u00e9m de fora. Para verificar isso, basta lan\u00e7ar uma BFS (no grafo transposto) para cada filho do n\u00f3 i (no grafo original). Se existir um n\u00f3 que foi visitado pelos dois filhos de i e que alcan\u00e7a i no grafo original, ent\u00e3o a resposta \u00e9 Y, caso contr\u00e1rio N.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n; cin &gt;&gt; n;\n    vector&lt;vector&lt;int&gt;&gt; adj(n + 1, vector&lt;int&gt;());\n    vector&lt;vector&lt;int&gt;&gt; adjt(n + 1, vector&lt;int&gt;());\n\n    for (int i = 1; i &lt;= n; i++) {\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n\n        adj[i].push_back(b);\n        adj[i].push_back(a);\n\n        adjt[a].push_back(i);\n        adjt[b].push_back(i);\n    }\n\n    auto bfs = [](int s, int i, vector&lt;vector&lt;int&gt;&gt; adj) {\n        int n = (int)adj.size() - 1;\n        queue&lt;int&gt; q;\n        vector&lt;bool&gt; used(n + 1, false);\n\n        q.push(s);\n        used[s] = true;\n\n        while (!q.empty()) {\n            auto x = q.front();\n            q.pop();\n\n            if (x == i) continue;\n\n            for (auto e : adj[x]) {\n                if (!used[e]) {\n                    used[e] = true;\n                    q.push(e);\n                }\n            }\n        }\n\n        return used;\n    };\n\n    vector&lt;vector&lt;bool&gt;&gt; vis(n + 1, vector&lt;bool&gt;(n + 1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        vis[i] = bfs(i, -1, adj);\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        int f1 = adj[i][0];\n        int f2 = adj[i][1];\n\n        auto vis1 = bfs(f1, i, adjt);\n        auto vis2 = bfs(f2, i, adjt);\n\n        bool flag = false;\n\n        for (int u = 1; u &lt;= n; u++) {\n            if (u == i) continue;\n\n            if (vis1[u] &amp;&amp; vis2[u] &amp;&amp; vis[u][i]) {\n                flag = true;\n            }\n        }\n\n        if (flag) {\n            cout &lt;&lt; \"Y\";\n        } else {\n            cout &lt;&lt; \"N\";\n        }\n    }\n    cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> D. Daily Trips <p>     S\u00f3 simular.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define vi vector&lt;int&gt;\n#define vl vector&lt;ll&gt;\n#define vii vector&lt;pii&gt;\n#define vll vector&lt;pll&gt;\n#define all(x) (x).begin(), (x).end()\n#define teto(a, b) (((a)+(b)-1)/(b))\n#define endl '\\n'\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nconst int MAX = 1e5+17;\nconst int INF = 1e9+17;\nconst ll LLINF = 0x3f3f3f3f3f3f3f3fLL;\nconst int MOD = 1000000007;\nconst ld EPS = 1e-8;\nconst ld PI = acos(-1);\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, h, w; cin &gt;&gt; n &gt;&gt; h &gt;&gt; w;\n    for (int i = 0; i &lt; n; i++) {\n        char a, b; cin &gt;&gt; a &gt;&gt; b;\n\n        if (a == 'Y' or w == 0) {\n            h--;\n            w++;\n            cout &lt;&lt; \"Y\";\n        } else {\n            cout &lt;&lt; \"N\";\n        }\n\n        cout &lt;&lt; ' ';\n\n        if (b == 'Y' or h == 0) {\n            h++;\n            w--;\n            cout &lt;&lt; \"Y\";\n        } else {\n            cout &lt;&lt; \"N\";\n        }\n\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> E. Empty Squares <p>     Dado que \\(X \\) \u00e9 o tamanho do menor lado, se \\(X \\leq 10 \\) utilizamos uma DP \\(N \\times N \\times 10 \\), caso contr\u00e1rio a resposta \u00e9 sempre \\(0 \\).   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define vi vector&lt;int&gt;\n#define vl vector&lt;ll&gt;\n#define vii vector&lt;pii&gt;\n#define vll vector&lt;pll&gt;\n#define all(x) (x).begin(), (x).end()\n#define teto(a, b) (((a)+(b)-1)/(b))\n#define endl '\\n'\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing tii = tuple&lt;int, int, int&gt;;\n\nconst int MAX = 110;\nconst int INF = 1e9+17;\nconst ll LLINF = 0x3f3f3f3f3f3f3f3fLL;\nconst int MOD = 1000000007;\nconst ld EPS = 1e-8;\nconst ld PI = acos(-1);\n\nint sz1, sz2, kt, n;\nvector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; tb;\n\nint dp(int i, int j, int k) {\n    if (i &gt; n) return j + k;\n\n    int&amp; ans = tb[i][j][k];\n    if (ans != -1) return ans;\n\n    ans = dp(i+1, j, k);\n\n    if (i != kt) {\n        if (i &lt;= j) {\n            ans = min(ans, dp(i+1, j-i, k));\n        }\n\n        if (i &lt;= k) {\n            ans = min(ans, dp(i+1, j, k-i));\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int e; cin &gt;&gt; n &gt;&gt; kt &gt;&gt; e;\n\n    sz1 = e;\n    sz2 = n - e - kt;\n\n    if (sz1 &gt; sz2) swap(sz1, sz2);\n\n    if (sz1 &lt;= 10) {\n        tb.assign(n + 2, vector&lt;vector&lt;int&gt;&gt;(sz1 + 2, vector&lt;int&gt;(sz2 + 2, -1)));\n        cout &lt;&lt; dp(0, sz1, sz2) &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; \"0\\n\";\n    }\n\n    return 0;\n}\n</code></pre> H. Horse Race <p>     Imagine um grafo bipartido conectando todas as posi\u00e7\u00f5es \u00e0 todos os cavalos. Basta ir retirando arestas desse grafo completo conforme o input for restringindo quem pode ficar em qual posi\u00e7\u00e3o. Ap\u00f3s isso basta encontrar o maximum matching com algum algoritmo eficiente.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\n\nconst ll FLOW_INF = 1e18 + 7;\n\nstruct Edge {\n    int from, to;\n    ll cap, flow;\n    Edge* residual; // a inversa da minha aresta\n\n    Edge() {};\n\n    Edge(int from, int to, ll cap) : from(from), to(to), cap(cap), flow(0) {};\n\n    ll remaining_cap() {\n        return cap - flow;\n    }\n\n    void augment(ll bottle_neck) {\n        flow += bottle_neck;\n        residual-&gt;flow -= bottle_neck;\n    }\n\n    bool is_residual() {\n        return cap == 0;\n    }\n};\n\nstruct Dinic {\n    int n;\n    vector&lt;vector&lt;Edge*&gt;&gt; adj;\n    vector&lt;int&gt; level, next;\n\n    Dinic(int n): n(n) {\n        adj.assign(n+1, vector&lt;Edge*&gt;());\n        level.assign(n+1, -1);\n        next.assign(n+1, 0);\n    }\n\n    void add_edge(int from, int to, ll cap) {\n        auto e1 = new Edge(from, to, cap);\n        auto e2 = new Edge(to, from, 0);\n\n        e1-&gt;residual = e2;\n        e2-&gt;residual = e1;\n\n        adj[from].push_back(e1);\n        adj[to].push_back(e2);\n    }\n\n    bool bfs(int s, int t) {\n        fill(level.begin(), level.end(), -1);\n        queue&lt;int&gt; q;\n\n        q.push(s);\n        level[s] = 1;\n\n        while (q.size()) {\n            int curr = q.front();\n            q.pop();\n\n            for (auto edge : adj[curr]) {\n                if (edge-&gt;remaining_cap() &gt; 0 &amp;&amp; level[edge-&gt;to] == -1) {\n                    level[edge-&gt;to] = level[curr] + 1;\n                    q.push(edge-&gt;to);\n                }\n            }\n        }\n\n        return level[t] != -1;\n    }\n\n    ll dfs(int x, int t, ll flow) {\n        if (x == t) return flow;\n\n        for (int&amp; cid = next[x]; cid &lt; (int)adj[x].size(); cid++) {\n            auto&amp; edge = adj[x][cid];\n            ll cap = edge-&gt;remaining_cap();\n\n            if (cap &gt; 0 &amp;&amp; level[edge-&gt;to] == level[x] + 1) {\n                ll sent = dfs(edge-&gt;to, t, min(flow, cap)); // bottle neck\n                if (sent &gt; 0) {\n                    edge-&gt;augment(sent);\n                    return sent;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    ll solve(int s, int t) {\n        ll max_flow = 0;\n\n        while (bfs(s, t)) {\n            fill(next.begin(), next.end(), 0);\n\n            while (ll sent = dfs(s, t, FLOW_INF)) {\n                max_flow += sent;\n            }\n        }\n\n        return max_flow;\n    }\n\n    // path recover\n    vector&lt;bool&gt; vis;\n    vector&lt;int&gt; curr;\n\n    bool dfs2(int x, int&amp; t) {\n        vis[x] = true;\n        bool arrived = false;\n\n        if (x == t) {\n            curr.push_back(x);\n            return true;\n        }\n\n        for (auto e : adj[x]) {\n            if (e-&gt;flow &gt; 0 &amp;&amp; !vis[e-&gt;to]) { // !e-&gt;is_residual() &amp;&amp; \n                bool aux = dfs2(e-&gt;to, t);\n\n                if (aux) {\n                    arrived = true;\n                    e-&gt;flow--;\n                }\n            }\n        }\n\n        if (arrived) curr.push_back(x);\n\n        return arrived;\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; get_paths(int s, int t) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        while (true) {\n            curr.clear();\n            vis.assign(n+1, false);\n\n            if (!dfs2(s, t)) break;\n\n            reverse(curr.begin(), curr.end());\n            ans.push_back(curr);\n        }\n\n        return ans;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n; cin &gt;&gt; n;\n    map&lt;string, int&gt; idx;\n    vector&lt;string&gt; arr(n + 1);\n\n    Dinic dinic(n + n + 7);\n    int source = n + n + 3, target = n + n + 4;\n\n    for (int i = 1; i &lt;= n; i++) {\n        string x; cin &gt;&gt; x;\n\n        idx[x] = i;\n        arr[i] = x;\n\n        dinic.add_edge(source, i, 1);\n        dinic.add_edge(i + n, target, 1);\n    }\n\n    int r; cin &gt;&gt; r;\n\n    vector&lt;int&gt; lst(n + 1, 0);\n    vector&lt;vector&lt;set&lt;int&gt;&gt;&gt; pos(n + 1, vector&lt;set&lt;int&gt;&gt;());\n    vector&lt;bool&gt; aparece_input(n + 1, false);\n\n    for (int i = 0; i &lt; r; i++) {\n        int m, w; cin &gt;&gt; m &gt;&gt; w;\n        set&lt;int&gt; cur;\n\n        aparece_input[w] = true;\n\n        for (int j = 0; j &lt; m; j++) {\n            string aux; cin &gt;&gt; aux;\n\n            int id = idx[aux];\n\n            // dinic.add_edge(id, w + n, 1);\n\n            cur.insert(id);\n\n            lst[id] = max(lst[id], w);\n        }\n\n        pos[w].push_back(cur);\n    }\n\n    for (int p = 1; p &lt;= n; p++) {\n        vector&lt;int&gt; cnt(n + 1);\n\n        for (auto x : pos[p]) {\n            for (auto e : x) {\n                cnt[e]++;\n            }\n        }\n\n        for (int i = 1; i &lt;= n; i++) {\n            if (cnt[i] == (int)pos[p].size() &amp;&amp; cnt[i] &gt; 0 &amp;&amp; lst[i] == p) {\n                // cout &lt;&lt; arr[i] &lt;&lt; ' ' &lt;&lt; p &lt;&lt; endl;\n                dinic.add_edge(i, p + n, 1);\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = lst[i] + 1; j &lt;= n; j++) {\n            if (aparece_input[j]) continue;\n\n            // cout &lt;&lt; arr[i] &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl;\n            dinic.add_edge(i, j + n, 1);\n        }\n    }\n\n    vector&lt;int&gt; res(n + 1);\n\n    int max_pairs = dinic.solve(source, target);\n    auto ans = dinic.get_paths(source, target);\n\n    for (auto e : ans) {\n        res[e[2] - n] = e[1];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; arr[res[i]] &lt;&lt; ' ';\n    }\n\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> I. Italian Calzone &amp; Pasta Corner <p>     Testa, para cada elemento, lan\u00e7ar uma esp\u00e9cie de bfs pegando uma sequ\u00eancia crescente.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define vi vector&lt;int&gt;\n#define vl vector&lt;ll&gt;\n#define vii vector&lt;pii&gt;\n#define vll vector&lt;pll&gt;\n#define all(x) (x).begin(), (x).end()\n#define teto(a, b) (((a)+(b)-1)/(b))\n#define endl '\\n'\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nconst int MAX = 1e5+17;\nconst int INF = 1e9+17;\nconst ll LLINF = 0x3f3f3f3f3f3f3f3fLL;\nconst int MOD = 1000000007;\nconst ld EPS = 1e-8;\nconst ld PI = acos(-1);\n\nconst int MAXN = 110;\nint r, c;\nvector&lt;vector&lt;int&gt;&gt; arr(MAXN, vector&lt;int&gt;(MAXN));\n\nint di[] = {0, 0, 1, -1};\nint dj[] = {1, -1, 0, 0};\n\nint solve(int i, int j) {\n\n    int ans = 0;\n\n    set&lt;array&lt;int, 3&gt;&gt; st = {{arr[i][j], i, j}};\n\n    vector&lt;vector&lt;int&gt;&gt; used(MAXN, vector&lt;int&gt;(MAXN));\n\n    used[i][j] = 1;\n\n    while((int)st.size()) {\n        ans += 1;\n        auto cur = *st.begin();\n        st.erase(st.begin());\n        for(int p = 0; p &lt; 4; p++) {\n            int ix = cur[1] + di[p];\n            int jx = cur[2] + dj[p];\n\n            if(ix &gt;= 0 &amp;&amp; jx &gt;= 0 &amp;&amp; ix &lt; r &amp;&amp; jx &lt; c &amp;&amp; !used[ix][jx] &amp;&amp; arr[ix][jx] &gt; cur[0]) {\n                st.insert({arr[ix][jx], ix, jx});\n                used[ix][jx] = 1;\n            }\n        }\n    }\n\n    return ans;\n\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int ans = 0;\n    cin &gt;&gt; r &gt;&gt; c;\n\n    for(int i = 0; i &lt; r; i++) {\n        for(int j = 0; j &lt; c; j++) {\n            cin &gt;&gt; arr[i][j];\n        }\n    }\n\n    for(int i = 0; i &lt; r; i++) {\n        for(int j = 0; j &lt; c; j++) {\n            ans = max(ans, solve(i, j));\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> L. Lazy Printing <p>     \u00c9 um guloso procurando qual valor de \\(d \\) leva mais longe, e ent\u00e3o pule para ele e repita o processo. Assumindo que voc\u00ea est\u00e1 no n\u00f3 \\(i \\) testando um valor \\(d_i \\), basta achar o maior k onde as strings [i + (k - 1) * di, i + k * di] s\u00e3o iguais e depois ir incrementando para achar o maior prefixo comum (pode ser iterando mesmo). Veja o c\u00f3digo para mais detalhes.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = (int)1e9+7;\n\nstruct Hash {\n    const ll P = 31;\n    int n; string s;\n    vector&lt;ll&gt; h, hi, p;\n    Hash() {}\n    Hash(string s): s(s), n(s.size()), h(n), hi(n), p(n) {\n        for (int i=0;i&lt;n;i++) p[i] = (i ? P*p[i-1]:1) % MOD;\n        for (int i=0;i&lt;n;i++)\n            h[i] = (s[i] + (i ? h[i-1]:0) * P) % MOD;\n        for (int i=n-1;i&gt;=0;i--) \n            hi[i] = (s[i] + (i+1&lt;n ? hi[i+1]:0) * P) % MOD;\n    }\n    int query(int l, int r) {\n        ll hash = (h[r] - (l ? h[l-1]*p[r-l+1]%MOD : 0));\n        return hash &lt; 0 ? hash + MOD : hash;\n    }\n    int query_inv(int l, int r) {\n        ll hash = (hi[l] - (r+1 &lt; n ? hi[r+1]*p[r-l+1] % MOD : 0));\n        return hash &lt; 0 ? hash + MOD : hash;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string s; int d; cin &gt;&gt; s &gt;&gt; d;\n    int n = s.size();\n\n    Hash hash(s);\n\n    int it = 0, ans = 0;\n    while (it &lt; n) {\n\n        int mx_pos = 0;\n\n        for (int i = 1; i &lt;= d; i++) {\n            int jt = it;\n\n            while (jt + i - 1 &lt; n &amp;&amp; hash.query(it, it + i - 1) == hash.query(jt, jt + i - 1)) {\n                jt += i;\n            }\n\n            int aux = 0;\n            while (jt &lt; n &amp;&amp; s[it + aux] == s[jt]) {\n                jt++;\n                aux++;\n            }\n\n            mx_pos = max(mx_pos, jt);\n\n        }\n\n        ans++;\n        it = mx_pos;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> M. Maze in Bolt <p>     Para cada linha \\(i \\), calcula se alguma das \\(n \\) rota\u00e7\u00f5es da string original pode ser encaixada nela, e ent\u00e3o salva numa tabela. Ent\u00e3o temos que \\(rot[i][j] \\) indica que a string original se encaixa na string da linha \\(i \\) usando \\(j \\) rota\u00e7\u00f5es. Dada essa matriz de rota\u00e7\u00f5es, o que queremos \u00e9 sair da primeira linha e chegar na \u00faltima passando somente por posi\u00e7\u00f5es \\(true \\), o que pode ser feito com uma BFS multisource, partindo de todo elemento da primeira linha que \u00e9 verdadeiro.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n#define ll long long\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define pii pair&lt;int, int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define vi vector&lt;int&gt;\n#define vl vector&lt;ll&gt;\n#define vii vector&lt;pii&gt;\n#define vll vector&lt;pll&gt;\n#define all(x) (x).begin(), (x).end()\n#define teto(a, b) (((a)+(b)-1)/(b))\n#define endl '\\n'\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nconst int MAX = 1010;\nconst int INF = 1e9+17;\nconst ll LLINF = 0x3f3f3f3f3f3f3f3fLL;\nconst int MOD = 1000000007;\nconst ld EPS = 1e-8;\nconst ld PI = acos(-1);\n\nint r, c;\nstring arr[MAX];\nbool has[MAX][MAX], used[MAX][MAX];\n\nvoid can(string&amp; s, string&amp; t, int idx) {\n    int n = s.size();\n\n    for (int i = 0; i &lt; n; i++) {\n        bool flag = true;\n\n        for (int j = 0; j &lt; n; j++) {\n            if (s[(i + j) % n] == '1' &amp;&amp; t[j] == '1') {\n                flag = false;\n                break;\n            }\n        }\n\n        has[idx][i] = flag;\n    }\n}\n\nbool solve(string s) {\n    for (int i = 0; i &lt; r; i++) {\n        can(s, arr[i], i);\n    }\n\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n\n    for (int i = 0; i &lt; c; i++) {\n        if (has[0][i]) {\n            q.push({0, i});\n            used[0][i] = true;\n        }\n    }\n\n    while (!q.empty()) {\n        auto [i, rot] = q.front();\n        q.pop();\n\n        if (i == r - 1) {\n            return true;\n        }\n\n        if (i-1 &gt;= 0 &amp;&amp; has[i-1][rot] &amp;&amp; !used[i-1][rot]) {\n            q.push({ i - 1, rot });\n            used[i-1][rot] = true;\n        }\n\n        if (has[i+1][rot] &amp;&amp; !used[i+1][rot]) {\n            q.push({ i + 1, rot });\n            used[i+1][rot] = true;\n        }\n\n        if (has[i][(rot+1)%c] &amp;&amp; !used[i][(rot+1)%c]) {\n            q.push({ i, (rot+1)%c });\n            used[i][(rot+1)%c] = true;\n        }\n\n        if (has[i][(rot-1+c)%c] &amp;&amp; !used[i][(rot-1+c)%c]) {\n            q.push({ i, (rot-1+c)%c });\n            used[i][(rot-1+c)%c] = true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; r &gt;&gt; c;\n\n    string s; cin &gt;&gt; s;\n\n    for (int i = 0; i &lt; r; i++) {\n        cin &gt;&gt; arr[i];\n    }\n\n    if (solve(s)) {\n        cout &lt;&lt; \"Y\" &lt;&lt; endl;\n        return 0;\n    }\n\n    memset(has, 0, sizeof(has));\n    memset(used, 0, sizeof(used));\n\n    reverse(s.begin(), s.end());\n\n    if (solve(s)) {\n        cout &lt;&lt; \"Y\" &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"N\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"training/Nacionais/2022/#upsolving","title":"Upsolving","text":"<p>C</p> <p>B F G J K</p>"},{"location":"training/UnBalloon/V_Maratona_UnBalloon/","title":"V Maratona UnBalloon","text":"<p>Feito em 26/08/2023</p>"},{"location":"training/UnBalloon/V_Maratona_UnBalloon/#problemas","title":"Problemas","text":"A. A porta dos desesperados <p>     A \u00fanica probabilidade que importa s\u00e3o as das portas da cor que cont\u00e9m o pr\u00eamio, pois se escolhemos a porta de uma outra cor elas s\u00e3o eliminadas.   </p> <p>Ent\u00e3o a probabilidade de escolher a porta do pr\u00eamio \u00e9: \\(\\dfrac{1}{cnt[porta]}\\)</p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    char choose; cin &gt;&gt; choose;\n\n    map&lt;char, int&gt; doors;\n\n    cin &gt;&gt; doors['R'];\n    cin &gt;&gt; doors['G'];\n    cin &gt;&gt; doors['B'];\n\n    cout &lt;&lt; fixed &lt;&lt; setprecision(12) &lt;&lt; (double)1 / doors[choose] &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> B. Bomba-rel\u00f3gio <p>     Observe que o n\u00famero cont\u00e9m somente 18 d\u00edgitos, ent\u00e3o \u00e9 poss\u00edvel simular com busca em largura (BFS) at\u00e9 chegar na resposta, que converge r\u00e1pido, e depois recuperar a resposta da BFS.   </p> <p>Fique atento com overflow ao realizar a opera\u00e7\u00e3o de produto.</p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair&lt;int, int&gt;;\nusing vi = vector&lt;int&gt;;\n\nll desloca(ll x) {\n    if (x &lt; 10) return x;\n\n    string cur = to_string(x);\n    string aux = \"\";\n\n    for (int i = 0; i &lt; (int)cur.size() - 1; i++) {\n        aux += cur[i];\n    }\n\n    return stoll(aux);\n}\n\nvoid solve() {\n\n    ll x; cin &gt;&gt; x;\n\n    queue&lt;pair&lt;ll, int&gt;&gt; q;\n    map&lt;ll, bool&gt; used;\n    map&lt;ll, pair&lt;ll, char&gt;&gt; p;\n\n    q.push({x, 0});\n    used[x] = true;\n    p[x] = {-1, '$'};\n\n    ll ans;\n\n    while (true) {\n        auto [v, dis] = q.front();\n        q.pop();\n\n        if (v &lt; 0) continue;\n\n        if (v == 1) {\n            ans = dis;\n            break;\n        }\n\n        ll cur = v * 3;\n\n        if ((double)v * 3.0 &lt;= 1e18 &amp;&amp; !used[cur]) {\n            used[cur] = true;\n            q.push({cur, dis + 1});\n            p[cur] = {v, 'L'};\n        }\n\n        cur = desloca(v);\n\n        if (!used[cur]) {\n            used[cur] = true;\n            q.push({ cur, dis + 1 });\n            p[cur] = {v, 'R'};\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n\n    string s = \"\";\n\n    ll cur = 1;\n\n    while (p[cur].first != -1) {\n        s += p[cur].second;\n        cur = p[cur].first;\n    }\n\n    reverse(s.begin(), s.end());\n\n    cout &lt;&lt; s &lt;&lt; '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t = 1;\n\n    while(t--) {\n        solve();\n    }\n\n}\n</code></pre> C. Conflito PUCmon <p>     \u00c9 s\u00f3 fazer.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string name, type; cin &gt;&gt; name &gt;&gt; type;\n\n    map&lt;string, string&gt; suf;\n\n    suf[\"fogo\"] = \"zard\";\n    suf[\"eletricidade\"] = \"chu\";\n    suf[\"agua\"] = \"tle\";\n    suf[\"agua\"] = \"tle\";\n    suf[\"grama\"] = \"ssauro\";\n    suf[\"lutador\"] = \"pablo\";\n    suf[\"normal\"] = \"\";\n\n    cout &lt;&lt; name &lt;&lt; suf[type] &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> D. Duda e suas matrizes <p> </p> C\u00f3digo <pre><code>\n</code></pre> E. Encontrando o Culpado <p>     \u00c9 s\u00f3 fazer. D\u00ea uma olhada no c\u00f3digo da solu\u00e7\u00e3o e v\u00ea se tira algum proveito das \"\"\"t\u00e9cnicas\"\"\".   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n; cin &gt;&gt; n;\n    string s; cin &gt;&gt; s;\n\n    auto count = [&amp;](string t) {\n        int cnt = 0;\n\n        for (int i = 0; i &lt; n; i++) {\n            cnt += (s[i] == t[i]);\n        }\n\n        return cnt;\n    };\n\n    int m; cin &gt;&gt; m;\n    vector&lt;pair&lt;int, int&gt;&gt; arr(m);\n\n    for (int i = 0; i &lt; m; i++) {\n        string cur; cin &gt;&gt; cur;\n\n        arr[i] = { count(cur), -(i + 1) };\n    }\n\n    sort(arr.rbegin(), arr.rend());\n\n    for (auto [ff, ss] : arr) {\n        cout &lt;&lt; -ss &lt;&lt; ' ';\n    }\n    cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> F. Fus\u00e3o <p>     A quantidade de caras com o bit j = 0 tem que ser igual a quantidade de caras com o bit j = 1.      Por\u00e9m tem que levar em considera\u00e7\u00e3o a mask dos que j\u00e1 pegamos.      Se n\u00e3o for exatamente metade, ent\u00e3o esse bit vai ficar desligado no and, e n\u00e3o dividimos em dois sets.      Caso contr\u00e1rio, dividimos pq sabemos que ligar aquele bit vai maximizar a resposta.      E ent\u00e3o somamos 2^j na resposta.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n; cin &gt;&gt; n;\n    vector&lt;ll&gt; arr(n);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; arr[i];\n    }\n\n    ll ans = 0;\n    vector&lt;vector&lt;ll&gt;&gt; galera = { arr };\n\n    for (int j = 60; j &gt;= 0; j--) {\n        ll pot = (1LL &lt;&lt; j);\n\n        vector&lt;vector&lt;ll&gt;&gt; aux;\n\n        for (auto x : galera) {\n            vector&lt;ll&gt; ones, zeros;\n\n            for (auto e : x) {\n                if (pot &amp; e) {\n                    ones.push_back(e);\n                } else {\n                    zeros.push_back(e);\n                }\n            }\n\n            aux.push_back(zeros);\n            aux.push_back(ones);\n        }\n\n        bool has = true;\n\n        int sz = (int)aux.size();\n        for (int i = 0; i &lt; sz; i++) {\n            if (aux[i].size() != aux[sz - i - 1].size()) {\n                has = false;\n                break;\n            }\n        }\n\n        if (has) {\n            swap(galera, aux);\n            ans += pot;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> Aprendizado <p>       Desenhar ajudou muito.     </p> G. Grafo sem enrola\u00e7\u00e3o <p>     Construa um grafo direcionado com as arestas que ele deu no input. Agora vamos resolver o problema para cada componente conexo individualmente:   </p> <p>     Se tiver ciclo, a resposta \u00f3tima vai ser gastar N arestas, onde N \u00e9 o tamanho do componente conexo em quest\u00e3o, construindo um grafo que liga todos os n\u00f3s em sequ\u00eancia (a[0] -&gt; a[1] -&gt; a[2] -&gt; a[3] -&gt; ... -&gt; a[0]).   </p> <p>     Caso n\u00e3o exista ciclo, a resposta \u00f3tima vai ser gastar N - 1 arestas, construindo um grafo linha que liga os n\u00f3s em sequ\u00eancia de acordo com a ordena\u00e7\u00e3o topol\u00f3gica do grafo (topo[0] -&gt; topo[1] -&gt; topo[2] -&gt; ... -&gt; topo[N - 1]).   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\n\nconst int MAX = (int)1e5+17;\n\nvector&lt;int&gt; adj[MAX], adj2[MAX];\nbool ex[MAX], used2[MAX], has_cycle[MAX];\nint state[MAX], comp[MAX];\n\nvector&lt;vector&lt;int&gt;&gt; topo;\n\nvoid dfs2(int x, int idx) {\n    used2[x] = true;\n    comp[x] = idx;\n\n    for (auto e : adj2[x]) {\n        if (!used2[e]) {\n            dfs2(e, idx);\n        }\n    }\n}\n\nvoid dfs(int x) {\n    state[x] = 1;\n\n    for (auto e : adj[x]) {\n        if (state[e] == 0) {\n            dfs(e);\n        } else if (state[e] == 1) {\n            has_cycle[comp[x]] = true;\n        }\n    }\n\n    state[x] = 2;\n\n    topo[comp[x]].push_back(x);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; m; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n\n        adj[u].push_back(v);\n\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n\n        ex[u] = ex[v] = true;\n    }\n\n    // id pra cada componente\n\n    int idx = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (ex[i] &amp;&amp; !used2[i]) {\n            dfs2(i, idx++);\n        }\n    }\n\n    topo.assign(idx, vector&lt;int&gt;());\n\n    // quais componentes tem ciclo?\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (ex[i] &amp;&amp; state[i] == 0) {\n            dfs(i);\n        }\n    }\n\n    // calcula resposta\n\n    vector&lt;pair&lt;int, int&gt;&gt; ans;\n\n    for (int i = 0; i &lt; idx; i++) {\n        reverse(topo[i].begin(), topo[i].end());\n\n        for (int j = 1; j &lt; (int)topo[i].size(); j++) {\n            ans.push_back({ topo[i][j-1], topo[i][j] });\n        }\n\n        if (has_cycle[comp[ topo[i].back() ]]) {\n            ans.push_back({ topo[i].back(), topo[i][0] });\n        }\n    }\n\n    cout &lt;&lt; ans.size() &lt;&lt; '\\n';\n\n    for (auto [u, v] : ans) {\n        cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre> H. Handle Secreta <p> </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ff first\n#define ss second\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing pii = pair&lt;int, int&gt;;\n\nconst int MAX = (int)1e5 + 17;\n\nbool check(pii a, pii b) {\n    if (a.ff &gt;= b.ff &amp;&amp; a.ff &lt;= b.ss) return true;\n    if (a.ss &gt;= b.ff &amp;&amp; a.ss &lt;= b.ss) return true;\n\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, k, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;\n    vector&lt;vector&lt;pii&gt;&gt; itv(n + 1, vector&lt;pii&gt;());\n\n    for (int i = 0; i &lt; k; i++) {\n        int idx, l, r; cin &gt;&gt; idx &gt;&gt; l &gt;&gt; r;\n\n        itv[idx].push_back({l, r});\n    }\n\n    int len = (int)sqrt(k);\n\n    vector&lt;vector&lt;int&gt;&gt; ps(n + 1, vector&lt;int&gt;()), psl(n + 1, vector&lt;int&gt;());\n\n    for (int i = 1; i &lt;= n; i++) {\n        sort(itv[i].begin(), itv[i].end());\n\n        if ((int)itv[i].size() &gt;= len) {\n            ps[i].assign(m + 1, 0);\n            psl[i].assign(m + 1, 0);\n\n            for (auto [l, r] : itv[i]) {\n                ps[i][l]++;\n                ps[i][r + 1]--;\n\n                psl[i][l]++;\n            }\n\n            for (int j = 1; j &lt;= m; j++) {\n                ps[i][j] += ps[i][j - 1];\n\n                psl[i][j] += psl[i][j - 1];\n            }\n        }\n    }\n\n    map&lt;pair&lt;int, int&gt;, bool&gt; has;\n\n    while (q--) {\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n\n        if (itv[a].size() &gt; itv[b].size()) {\n            swap(a, b);\n        }\n\n        if (has.find({a, b}) == has.end()) {\n            bool&amp; ans = has[{a, b}];\n\n            if (itv[b].size() &gt;= len) {\n                for (auto [l, r] : itv[a]) {\n                    if (ps[b][r] &gt; 0) {\n                        ans = true;\n                        break;\n                    } else if (ps[b][l] &gt; 0) {\n                        ans = true;\n                        break;\n                    } else if (psl[b][r] - psl[b][l - 1] &gt; 0) {\n                        ans = true;\n                        break;\n                    }\n                }\n            } else {\n                int jt = 0;\n\n                for (int it = 0; it &lt; (int)itv[a].size(); it++) {\n                    while (jt &lt; (int)itv[b].size() &amp;&amp; itv[b][jt].second &lt;= itv[a][it].first) { // r_b &gt; l_a\n                        jt++;\n                    }\n\n                    if (jt &lt; (int)itv[b].size() &amp;&amp; (check(itv[a][it], itv[b][jt]) || check(itv[b][jt], itv[a][it]))) {\n                        ans = true;\n                    }\n                }\n            }\n\n        }\n\n        cout &lt;&lt; (has[{a, b}] ? \"Nao eh o Tiagobfs :c\" : \"TIAGOBFS???\") &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre> I. Inventando a Exponencial <p> </p> C\u00f3digo <pre><code>\n</code></pre> J. Jotinha no Jogo <p> V\u00eddeo explicando. </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = (int)1e9+7;\n\nll fexp(ll base, ll exp, ll m) {\n    ll ans = 1;\n    base %= m;\n\n    while (exp &gt; 0) {\n        if (exp % 2 == 1) {\n            ans = (ans * base) % m;\n        }\n\n        base = (base * base) % m;\n        exp /= 2;\n    }\n\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t; cin &gt;&gt; t;\n    while (t--) {\n        ll a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n        ll num = (a * a + b * a - c * a) % MOD;\n        ll den = (a + b);\n\n        ll ans = (num * fexp(den, MOD - 2, MOD)) % MOD;\n\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre> K. K\u00e1tia e os pal\u00edndromos de C\u00e9sar <p>     \u00c9 poss\u00edvel pr\u00e9-computar 26 hashs da string original, uma para cada rota\u00e7\u00e3o, e ent\u00e3o testar cada substring [i, i+m] se, para alguma rota\u00e7\u00e3o, a condi\u00e7\u00e3o \u00e9 satisfeita (primeira metade da string == segunda metade da string invertida e rotacionada k vezes), e se for, incrementa a resposta e passa para a pr\u00f3xima posi\u00e7\u00e3o inicial i. Olhe o c\u00f3digo para mais detalhes.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = (int)1e9 + 7;\n\nstruct Hash {\n    const ll P = 31;\n    int n; string s;\n    vector&lt;ll&gt; h, hi, p;\n    Hash() {}\n    Hash(string s): s(s), n(s.size()), h(n), hi(n), p(n) {\n        for (int i=0;i&lt;n;i++) p[i] = (i ? P*p[i-1]:1) % MOD;\n        for (int i=0;i&lt;n;i++)\n            h[i] = (s[i] + (i ? h[i-1]:0) * P) % MOD;\n        for (int i=n-1;i&gt;=0;i--) \n            hi[i] = (s[i] + (i+1&lt;n ? hi[i+1]:0) * P) % MOD;\n    }\n    int query(int l, int r) {\n        ll hash = (h[r] - (l ? h[l-1]*p[r-l+1]%MOD : 0));\n        return hash &lt; 0 ? hash + MOD : hash;\n    }\n    int query_inv(int l, int r) {\n        ll hash = (hi[l] - (r+1 &lt; n ? hi[r+1]*p[r-l+1] % MOD : 0));\n        return hash &lt; 0 ? hash + MOD : hash;\n    }\n};\n\nstring rot(string s) {\n    for (auto &amp;c : s) {\n        c = char((((c - 'a') + 1) % 26) + 'a');\n    }\n\n    return s;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    string s; cin &gt;&gt; s;\n\n    vector&lt;Hash&gt; hash;\n\n    for (int i = 0; i &lt; 26; i++) {\n        hash.push_back(Hash(s));\n        s = rot(s);\n    }\n\n    if (m == 1) {\n        cout &lt;&lt; n &lt;&lt; '\\n';\n        return 0;\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i &lt;= n - m; i++) {\n        for (int k = 0; k &lt; 26; k++) {\n            if (m % 2 == 1) {\n                int it = hash[0].query(i, i + m / 2 - 1);\n                int jt = hash[k].query_inv(i + m / 2 + 1, i + m - 1);\n\n                if (it == jt) {\n                    ans++;\n                    break;\n                }\n            } else {\n                int it = hash[0].query(i, i + m / 2 - 1);\n                int jt = hash[k].query_inv(i + m / 2, i + m - 1);\n\n                if (it == jt) {\n                    ans++;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> L. Lenhadoras de segtree <p>     O problema aqui \u00e9 que, ao mudar de n\u00f3, enraizamos a \u00e1rvore no novo n\u00f3. Ao trocar de n\u00f3, queremos saber o tamanho do componente conexo do pai de x, que \u00e9 n - sz[x] (pense no porqu\u00ea). Ent\u00e3o, caso exista pai, somamos tamb\u00e9m o quadrado desse valor na resposta de x, al\u00e9m do quadrado dos filhos na \"\u00e1rvore original\" (enraizada em 1).   </p> <p>     Desenhar ajuda bastante. Leia o c\u00f3digo da DFS pra ficar mais claro.   </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\n\nconst int MAX = (int)2e5 + 17;\n\nint n;\nvector&lt;int&gt; adj[MAX];\nll sz[MAX], ans[MAX];\n\nvoid dfs_sz(int x, int p) {\n    sz[x] = 1;\n\n    for (auto e : adj[x]) {\n        if (e != p) {\n            dfs_sz(e, x);\n            sz[x] += sz[e];\n        }\n    }\n}\n\nvoid dfs(int x, int p) {\n    for (auto e : adj[x]) {\n        if (e != p) {\n            ans[x] += sz[e] * sz[e];\n        }\n    }\n\n    if (p != -1) {\n        ans[x] += (n - sz[x]) * (n - sz[x]);\n    }\n\n    for (auto e : adj[x]) {\n        if (e != p) {\n            dfs(e, x);\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n - 1; i++) {\n        int a, b; cin &gt;&gt; a &gt;&gt; b;\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    dfs_sz(1, 1);\n\n    dfs(1, 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; ' ';\n    }\n    cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> M. Mitose Marciana <p> </p> C\u00f3digo <pre><code>#include &lt;bits/stdc++.h&gt;\n\n// n acho que eu seja bom, mas eu ja fui pior\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nvector&lt;ll&gt; divisors(ll n) {\n    vector&lt;ll&gt; ans;\n\n    for (ll i = 1; i*i &lt;= n; i++) {\n        if (n%i == 0) {\n            ll value = n/i;\n\n            ans.push_back(i);\n            if (value != i) {\n                ans.push_back(value);\n            }\n        }\n    }\n\n    return ans;\n}\n\nll mul(ll a, ll b, ll m) {\n    ll ret = a*b - (ll)((ld)1/m*a*b+0.5)*m;\n    return ret &lt; 0 ? ret+m : ret;\n}\n\nll pow(ll a, ll b, ll m) {\n    ll ans = 1;\n    for (; b &gt; 0; b /= 2ll, a = mul(a, a, m)) {\n        if (b % 2ll == 1)\n            ans = mul(ans, a, m);\n    }\n    return ans;\n}\n\nbool prime(ll n) {\n    if (n &lt; 2) return 0;\n    if (n &lt;= 3) return 1;\n    if (n % 2 == 0) return 0;\n\n    ll r = __builtin_ctzll(n - 1), d = n &gt;&gt; r;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 795265022}) {\n        ll x = pow(a, d, n);\n        if (x == 1 or x == n - 1 or a % n == 0) continue;\n\n        for (int j = 0; j &lt; r - 1; j++) {\n            x = mul(x, x, n);\n            if (x == n - 1) break;\n        }\n        if (x != n - 1) return 0;\n    }\n    return 1;\n}\n\nll rho(ll n) {\n    if (n == 1 or prime(n)) return n;\n    auto f = [n](ll x) {return mul(x, x, n) + 1;};\n\n    ll x = 0, y = 0, t = 30, prd = 2, x0 = 1, q;\n    while (t % 40 != 0 or gcd(prd, n) == 1) {\n        if (x==y) x = ++x0, y = f(x);\n        q = mul(prd, abs(x-y), n);\n        if (q != 0) prd = q;\n        x = f(x), y = f(f(y)), t++;\n    }\n    return gcd(prd, n);\n}\n\nvector&lt;ll&gt; fact(ll n) {\n    if (n == 1) return {};\n    if (prime(n)) return {n};\n    ll d = rho(n);\n    vector&lt;ll&gt; l = fact(d), r = fact(n / d);\n    l.insert(l.end(), r.begin(), r.end());\n    return l;\n}\n\nll sum(ll n) {\n    auto factors = fact(n);\n\n    map&lt;ll, ll&gt; cnt;\n    for (auto f : factors) {\n        cnt[f]++;\n    }\n\n    ll ans = 1;\n\n    for (auto [p, a] : cnt) {\n        ans *= (pow(p, a + 1, LLONG_MAX) - 1) / (p - 1);\n    }\n\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    ll n; cin &gt;&gt; n;\n    auto div = divisors(n);\n\n    ll ans = 0;\n\n    for (auto e : div) {\n        ans += sum(e);\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"training/UnBalloon/V_Maratona_UnBalloon/#upsolving","title":"Upsolving","text":"<p>Todas feitas ;)</p>"}]}